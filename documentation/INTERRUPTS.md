**This is just a prototype to save some information and sources and will later be written fully and beautifuly**

[tutorial](https://samypesse.gitbook.io/how-to-create-an-operating-system/chapter-7)
[pic=programable interrupt controller](https://en.wikipedia.org/wiki/Programmable_interrupt_controller)
[idt=interrupt descriptor table](https://en.wikipedia.org/wiki/Interrupt_descriptor_table)
[isr=interrupt service routine](https://en.wikipedia.org/wiki/Interrupt_handler)
[irq=interrupt request](https://en.wikipedia.org/wiki/Interrupt_request)
[eoi=end of interrupt](https://en.wikipedia.org/wiki/End_of_interrupt)

The goal of the interrupt descriptor is to tell the cpu what to do (where to jump) when encountering that interrupt
Entry 32 bits https://wiki.osdev.org/Interrupt_descriptor_table#IDTR:~:text=Volume%203%2DA.-,Structure%20on%20IA%2D32,-Table
https://wiki.osdev.org/Interrupt_descriptor_table#IDTR

Little os P41
When an interrupt occurs the CPU will push some information about the interrupt onto the stack, then look
up the appropriate interrupt hander in the IDT and jump to it. The stack at the time of the interrupt will
look like the following:
[esp + 12] eflags
[esp + 8] cs
[esp + 4] eip
[esp] error code?

The specific CPU interrupts that put an error code on the stack are 8, 10, 11, 12, 13, 14 and 17
The interrupt number is not pushed onto the stack.
We can only determine what interrupt has occurred by knowing what code is executing - if the handler registered for interrupt 17 is executing, then interrupt 17 has occurred.
Once the interrupt handler is done, it uses the **iret** instruction to return. The instruction iret expects the
stack to be the same as at the time of the interrupt (see the figure above). Therefore, any values pushed onto
the stack by the interrupt handler must be popped. Before returning, iret restores eflags by popping the
value from the stack and then finally jumps to cs:eip as specified by the values on the stack.
The interrupt handler has to be written in assembly code, since all registers that the interrupt handlers use
must be preserved by pushing them onto the stack. This is because the code that was interrupted doesn’t
know about the interrupt and will therefore expect that its registers stay the same. Writing all the logic of
the interrupt handler in assembly code will be tiresome. Creating a handler in assembly code that saves the
registers, calls a C function, restores the registers and finally executes iret is a good idea!
The C handler should get the state of the registers, the state of the stack and the number of the interrupt as
arguments

[ASM MACROS]("https://www.nasm.us/xdoc/2.15.05/html/nasmdoc4.html#section-4.3")

The PIC makes it possible to map signals from the hardware to interrupts. The reasons for configuring the
PIC are:
• Remap the interrupts. The PIC uses interrupts 0 - 15 for hardware interrupts by default, which conflicts
with the CPU interrupts. Therefore the PIC interrupts must be remapped to another interval.
• Select which interrupts to receive. You probably don’t want to receive interrupts from all devices since
you don’t have code that handles these interrupts anyway.
• Set up the correct mode for the PIC.

Every interrupt from the PIC has to be acknowledged - that is, sending a message to the PIC confirming
that the interrupt has been handled. If this isn’t done the PIC won’t generate any more interrupts.
Acknowledging a PIC interrupt is done by sending the byte 0x20 to the PIC that raised the interrupt.
Implementing a pic_acknowledge function can thus be done as follows:

**The need for remapping the PIC**
The remapping of PIC (Programmable Interrupt Controller) interrupt values is primarily done for two reasons:

Avoiding Conflicts with CPU Exceptions:

The primary motivation for remapping PIC interrupt values is to avoid conflicts with CPU-generated exceptions. In x86 architecture, certain CPU-generated exceptions, such as divide-by-zero errors, page faults, and general protection faults, are associated with specific interrupt numbers. By default, these CPU exceptions are tied to low interrupt numbers, usually less than 0x20 (in hexadecimal) or 32 (in decimal). If PIC interrupts were assigned interrupt numbers in this lower range, there would be conflicts and confusion between hardware interrupts and CPU exceptions.
Organization and Clean Handling:

Remapping the PIC interrupts allows for a more organized and predictable system for handling hardware interrupts. By starting PIC interrupts at higher values, you create a clear distinction between CPU exceptions and hardware interrupts. This makes it easier for operating systems and software to handle and differentiate between various types of interrupts.
As for CPU interrupts, these are exceptions or traps generated by the CPU in response to various conditions. Some common examples of CPU interrupts include:

Divide-by-Zero Exception: Gener
ated when the CPU encounters a division by zero in an instruction.

General Protection Fault: Occurs when an instruction tries to access memory in an unauthorized or invalid manner, often due to privilege level violations.

Page Fault: Generated when an instruction or data access tries to access a memory page that is not currently in physical memory (requires a page swap from disk).

Double Fault: An exception that occurs when the CPU encounters an exception while trying to process another exception. This often indicates a severe system error.

Invalid Opcode: Generated when the CPU encounters an invalid or undefined opcode in an instruction.

Triple Fault: An extremely severe condition where the CPU encounters a double fault while trying to process a second fault, typically resulting in a system reset or crash.

These CPU-generated exceptions are part of the x86 architecture's exception mechanism, and they have well-defined interrupt numbers typically below 0x20. By remapping the PIC interrupts to higher values, it ensures that hardware interrupts are kept distinct from these CPU exceptions, making the handling of interrupts in the operating system and software more predictable and manageable.

https://en.wikibooks.org/wiki/X86_Assembly/Programmable_Interrupt_Controller

[PIC CONFIG](https://github.com/christianb93/ctOS/blob/master/doc/hardware/InterruptController.md)
https://github.com/christianb93/ctOS/blob/master/doc/system/InterruptHandling.md

https://github.com/0xAX/linux-insides/blob/master/Interrupts/linux-interrupts-1.md


P7,8 Image - https://rajivbhandari.files.wordpress.com/2014/12/unitii_8259.pdf

PIC Registers: ISR, IRR, IMR

**GOOD RESOURCE**
https://wiki.osdev.org/8259_PIC#Programming_with_the_8259_PIC

**We need to init the PIC because his settings match real mode settings and wont work for 32 bits**
In protected mode, the IRQs 0 to 7 conflict with the CPU exception which are reserved by Intel up until 0x1F.
It is thus recommended to change the PIC's offsets (also known as remapping the PIC) so that IRQs use non-reserved vectors. A common choice is to move them to the beginning of the available range (IRQs 0..0xF -> INT 0x20..0x2F). For that, we need to set the master PIC's offset to 0x20 and the slave's to 0x28. 

Perhaps the most common command issued to the PIC chips is the end of interrupt (EOI) command (code 0x20). This is issued to the PIC chips at the end of an IRQ-based interrupt routine. **If the IRQ came from the Master PIC, it is sufficient to issue this command only to the Master PIC; however if the IRQ came from the Slave PIC, it is necessary to issue the command to both PIC chips.**

Initialisation
When you enter protected mode (or even before hand, if you're not using GRUB) the first command you will need to give the two PICs is the initialise command (code 0x11). This command makes the PIC wait for 3 extra "initialisation words" on the data port. These bytes give the PIC:

Its vector offset. (ICW2)
Tell it how it is wired to master/slaves. (ICW3)
Gives additional information about the environment. (ICW4)

Read about "Spurious IRQs". May need to handle them.

**ISR**
https://wiki.osdev.org/ISR
https://wiki.osdev.org/Interrupts#So_how_do_I_program_this_stuff.3F

**interrupts numbers**
https://wiki.osdev.org/Interrupts#General_IBM-PC_Compatible_Interrupt_Information
https://wiki.osdev.org/Exceptions